"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sitemap = require("sitemap");

var _webpackSources = require("webpack-sources");

var _zlib = _interopRequireDefault(require("zlib"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const normalizeOptions = (options, keys) => {
  keys.forEach(key => {
    if (options[key]) {
      options[key.toLowerCase()] = options[key];
      delete options[key];
    }
  });
  return options;
};

const streamToString = stream => {
  let str = "";
  return new Promise(resolve => {
    stream.on("data", data => {
      str += data.toString();
    });
    stream.on("end", () => {
      resolve(str);
    });
  });
};

class SitemapWebpackPlugin {
  constructor(base, paths, options) {
    // Set mandatory values
    this.base = base;
    this.paths = paths; // Set options

    if (typeof options === "undefined") {
      options = {};
    }

    options = normalizeOptions(options, ["changeFreq", "fileName", "lastMod", "skipGzip"]);

    const {
      filename,
      skipgzip,
      formatter,
      lastmod,
      changefreq,
      priority
    } = options,
          rest = _objectWithoutProperties(options, ["filename", "skipgzip", "formatter", "lastmod", "changefreq", "priority"]);

    this.filename = filename ? filename.replace(/\.xml$/, "") : "sitemap";
    this.skipgzip = skipgzip || false;
    this.formatter = formatter || null;

    if (lastmod) {
      if (typeof lastmod === "string") {
        this.lastmod = lastmod;
      } else {
        this.lastmod = new Date().toISOString().split("T")[0];
      }
    }

    this.changefreq = changefreq;
    this.priority = priority;
    this.options = rest;
  }

  generateSitemap(paths) {
    const sitemap = new _sitemap.SitemapStream({
      hostname: this.base
    });
    paths.forEach(path => {
      if (typeof path === "object") {
        if (typeof path.path !== "string") {
          throw new Error(`Path is not a string: ${path}`);
        } else {
          // Clone the object so we can mutate it below without
          // potentially messing up the original we were given.
          path = _objectSpread({}, path);
        }
      } else if (typeof path === "string") {
        path = {
          path: path
        };
      } else {
        throw new Error(`Path is not a string: ${path}`);
      }

      path = normalizeOptions(path, ["changeFreq", "lastMod"]);

      const {
        path: url,
        changefreq,
        lastmod,
        priority
      } = path,
            rest = _objectWithoutProperties(path, ["path", "changefreq", "lastmod", "priority"]);

      const sitemapOptions = _objectSpread({}, this.options, {}, rest, {
        url
      });

      if (changefreq || this.changefreq) {
        sitemapOptions.changefreq = changefreq || this.changefreq;
      }

      if (lastmod || this.lastmod) {
        sitemapOptions.lastmod = lastmod || this.lastmod;
      }

      if (priority || this.priority) {
        sitemapOptions.priority = parseFloat(priority || this.priority);
      }

      sitemap.write(sitemapOptions);
    });
    sitemap.end();
    return this.sitemapStreamToString(sitemap);
  }

  async sitemapStreamToString(sitemapStream) {
    let sitemap = await streamToString(sitemapStream);

    if (this.formatter !== null) {
      sitemap = this.formatter(sitemap);
    }

    return sitemap;
  }

  async generate(publicPath) {
    // Validate configuration
    if (typeof this.base !== "string") {
      throw new Error("Provided base URL is not a string");
    } else if (this.base.substr(-1) === "/") {
      this.base = this.base.replace(/\/$/, "");
    }

    if (!Array.isArray(this.paths)) {
      throw new Error("Provided paths are not an array");
    }

    if (this.paths.length <= 50000) {
      const sitemap = await this.generateSitemap(this.paths);
      return [sitemap];
    } else {
      const output = [];
      const indexExt = this.skipgzip ? "xml" : "xml.gz";
      const sitemapIndex = new _sitemap.SitemapIndexStream();
      let index = 1;

      for (let i = 0; i < this.paths.length; i += 45000) {
        const sitemap = await this.generateSitemap(this.paths.slice(i, i + 45000));
        output.push(sitemap);
        sitemapIndex.write(`${this.base}${publicPath}/${this.filename}-${index}.${indexExt}`);
        index++;
      }

      sitemapIndex.end();
      const sitemapIndexStr = await this.sitemapStreamToString(sitemapIndex);
      output.unshift(sitemapIndexStr);
      return output;
    }
  }

  apply(compiler) {
    compiler.hooks.emit.tapAsync("sitemap-webpack-plugin", async (compilation, callback) => {
      let sitemaps = null;
      const publicPath = (compilation.options.output && compilation.options.output.publicPath || "").replace(/\/$/, "");

      try {
        sitemaps = await this.generate(publicPath);
        sitemaps.forEach((sitemap, idx) => {
          const sitemapFilename = idx === 0 ? `${this.filename}.xml` : `${this.filename}-${idx}.xml`;
          compilation.fileDependencies.add(sitemapFilename);
          compilation.assets[sitemapFilename] = new _webpackSources.RawSource(sitemap);
        });
      } catch (err) {
        compilation.errors.push(err.stack);
      }

      if (sitemaps !== null && this.skipgzip !== true) {
        let sitemapsZipped = 0;
        sitemaps.forEach((sitemap, idx) => {
          const sitemapFilename = idx === 0 ? `${this.filename}.xml.gz` : `${this.filename}-${idx}.xml.gz`;

          _zlib.default.gzip(sitemap, (err, compressed) => {
            if (err) {
              compilation.errors.push(err.stack);
            } else {
              compilation.assets[sitemapFilename] = new _webpackSources.RawSource(compressed);
            }

            sitemapsZipped++;

            if (sitemapsZipped === sitemaps.length) {
              callback();
            }
          });
        });
      } else {
        callback();
      }
    });
  }

}

exports.default = SitemapWebpackPlugin;